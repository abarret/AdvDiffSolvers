Allocating data
Setting up solution data
Creating finite element mesh
Extracting boundary mesh
Creating solver
input_db {
   N         = 32                                           // input used
   L         = 4                                            // input used
   RADIUS    = 1                                            // input used
   DX        = 0.125                                        // input used
   MFAC      = 1                                            // input used
   ELEM_TYPE = "TRI3"                                       // input used
   XCOM      = 0                                            // input used
   YCOM      = 0                                            // input used
   C         = 1                                            // input used
   D         = 1                                            // input used
   A         = 1                                            // input used
   B         = 0                                            // input used
   PoissonSolver {
      a            = 1                                      // input used
      b            = 0                                      // input used
      c            = 1                                      // input used
      d            = 1                                      // input used
      eps          = 0.03125                                // input used
      poly_degree  = 3                                      // input used
      stencil_size = 12                                     // input used
      ds           = 0.125                                  // input used
      com          = 0, 0                                   // input used
   }
   MeshMapping {
      max_level = 1                                         // input used
   }
   Q {
      l        = 4                                          // input used
      function = "sin(4.0*PI*X_0/l)*sin(4.0*PI*X_1/l)"      // input used
   }
   Laplacian {
      c        = 1                                          // input used
      d        = 1                                          // input used
      l        = 4                                          // input used
      r        = 1                                          // input used
      xcom     = 0                                          // input used
      ycom     = 0                                          // input used
      eps      = 0.03125                                    // input used
      function = "sqrt((X_0-xcom)*(X_0-xcom) + (X_1-ycom)*(X_1-ycom)) < (r + eps) ? sin(4.0*PI*X_0/l)*sin(4.0*PI*X_1/l) : (c - d * 32.0 * PI * PI / (l * l)) * sin(4.0*PI * X_0/l) * sin(4.0*PI * X_1/l)" // input used
   }
   ls {
      r        = 1                                          // input used
      xcom     = 0                                          // input used
      ycom     = 0                                          // input used
      function = "r - sqrt((X_0-xcom)*(X_0-xcom) + (X_1-ycom)*(X_1-ycom))" // input used
   }
   Main {
      log_file_name               = "output"                // input used
      log_all_nodes               = FALSE                   // input used
      viz_writer                  = "VisIt"                 // input used
      viz_dump_dirname            = "viz2d"                 // input used
      visit_number_procs_per_file = 1                       // input used
      timer_enabled               = TRUE                    // input not used
   }
   CartesianGeometry {
      domain_boxes       = [(0,0),(31,31)]                  // input used
      x_lo               = -2, -2                           // input used
      x_up               = 2, 2                             // input used
      periodic_dimension = 0, 0                             // input used
   }
   GriddingAlgorithm {
      max_levels                = 1                         // input used
      efficiency_tolerance      = 0.7                       // input used
      combine_efficiency        = 0.85                      // input used
      check_nonrefined_tags     = 'w'                       // from default
      check_overlapping_patches = 'i'                       // from default
      extend_tags_to_bdry       = FALSE                     // from default
      ratio_to_coarser {
         level_1 = 4, 4                                     // input not used
      }
      largest_patch_size {
         level_0 = 512, 512                                 // input used
      }
      smallest_patch_size {
         level_0 = 4, 4                                     // input used
      }
   }
   StandardTagAndInitialize {
      tagging_method = "REFINE_BOXES"                       // input used
      RefineBoxes {
         level_0 = [(8,8),(15,15)], [(16,8),(23,15)], [(8,16),(15,23)] // input used
      }
   }
   LoadBalancer {
      bin_pack_method                      = "SPATIAL"      // input used
      max_workload_factor                  = 1              // input used
      ignore_level_box_union_is_single_box = FALSE          // from default
   }
   TimerManager {
      print_exclusive      = FALSE                          // input used
      print_total          = TRUE                           // input used
      print_threshold      = 1                              // input used
      timer_list           = "IBTK::*::*"                   // input used
      print_processor      = TRUE                           // from default
      print_max            = FALSE                          // from default
      print_summed         = FALSE                          // from default
      print_user           = FALSE                          // from default
      print_sys            = FALSE                          // from default
      print_wall           = TRUE                           // from default
      print_percentage     = TRUE                           // from default
      print_concurrent     = FALSE                          // from default
      print_timer_overhead = FALSE                          // from default
   }
}
Filling initial condition
Initializing solver state
Copying data to petsc representation
Applying matrix
Copying data from petsc representation
Checking errors
Norms of error: 
  L1-norm:  10.2936
  L2-norm:  3.51398
  max-norm: 1.92683
Structure errors:
  L1-norm:  2.79263
  L2-norm:  1.48994
  max-norm: 1.07379
2.792629272 1.489939867 1.073794785
